//#region Proxies

/**
 * @typedef {import('../Report').Location} Location
 * @typedef {import('../Report').LogEntry} LogEntry
 */

/** @type {import('isolated-vm').Reference} */
const LOG_ENTRY_PROXY = $1

/** @type {import('isolated-vm').Reference} */
const DEBUG_PROXY = $2

/**
 * Next log entry ID
 */
let nextId = parseInt(`${$0.copySync()}`)

/**
 * Emit log entry
 * @param {LogEntry} entry Log entry
 */
function emitLogEntry(entry) {
    LOG_ENTRY_PROXY.applyIgnored(undefined, [entry], { arguments: { copy: true } })
}

/**
 * Emit debug message
 * @param {...unknown} args Arguments to log
 */
function emitDebug(...args) {
    DEBUG_PROXY.applyIgnored(undefined, args.map(item => `${item}`), { arguments: { copy: true } })
}


//#region Constants

/** Symbol to mark objects that are mocks, used to prevent mocking the same object twice */
const MockSymbol = Symbol(`Mock-${Math.random()}`)

/** Symbol to mark fully autogenerated templates, used to prevent mocking missing properties in "real" objects */
const FullMockSymbol = Symbol(`FullMock-${Math.random()}`)

/** Reference to original Proxy constructor */
const Proxy = globalThis.Proxy

/** Reference to original Reflect constructor */
const Reflect = globalThis.Reflect


//#region Utils

/**
 * Resolve path
 * @param  {string} parentPath Parent path
 * @param  {string} property   Property to append
 * @return {string}            New path
 */
function resolvePath(parentPath, property) {
    if (property === '()') {
        return `${parentPath}()`
    }
    return (parentPath === 'globalThis' ? '' : `${parentPath}.`) + property
}


//#region Mocks

/**
 * Is mock
 * @param  {any}     object Object to check
 * @return {boolean}        Whether object is mock
 */
function isMock(object) {
    return (object[MockSymbol] === MockSymbol)
}

/**
 * Create mock object (if possible)
 * @param  {string} path       Path to new object
 * @param  {any}    [template] Template to mock
 * @param  {any}    [thisArg]  For functions, custom `this` argument used during invocation
 * @return {object}            Mock object
 */
function createMock(path, template, thisArg) {
    // Is template a primitive type?
    const type = typeof template
    if (template === null || type === 'string' || type === 'number' || type === 'boolean' || type === 'symbol') {
        return template
    }

    // Create fully mock template if needed
    if (template === undefined) {
        template = function() {
            emitDebug('APPLY-RETURN trap for', path)
            return createMock(resolvePath(path, '()'))
        }
        template[FullMockSymbol] = FullMockSymbol
    }

    // Wrap template in proxy
    const proxy = new Proxy(template, {
        has(target, property) {
            return (target[FullMockSymbol] === FullMockSymbol) ? true : (property in target)
        },
        get(target, property) {
            // Handle symbol properties
            if (typeof property === 'symbol') {
                return (property === MockSymbol) ? MockSymbol : target[property]
            }

            // Handle ignored properties
            if (property === 'prototype') {
                return target[property]
            }

            // Create or get child mock
            const subpath = resolvePath(path, property)
            if (!(property in target)) {
                target[property] = createMock(subpath)
            } else if (!isMock(target[property])) {
                emitDebug(`> ${subpath} is not mocked`)
                target[property] = createMock(subpath, target[property], target)
            }

            // Return value
            emitDebug('GET trap for', subpath)
            return target[property]
        },
        set(target, property, newValue, receiver) {
            emitDebug('SET trap for', resolvePath(path, property))
            return Reflect.set(target, property, newValue, receiver)
        },
        construct(target, argArray, newTarget) {
            emitDebug('NEW trap for', path)
            const newInstance = Reflect.construct(target, argArray, newTarget)
            const newMock = createMock(resolvePath(path, '()'), newInstance)
            return newMock
        },
        apply(target, realThisArg, argArray) {
            emitDebug('APPLY trap for', path)
            return target.apply(thisArg ?? realThisArg, argArray)
        },
    })

    return proxy
}


//#region Initialize

// Hijack globalThis object
const originalGlobalThis = globalThis
const newGlobalThis = {}
newGlobalThis[Symbol.toPrimitive] = () => '[object Window]'
newGlobalThis[FullMockSymbol] = FullMockSymbol
for (const property of [
    'console',
    'eval',
    'decodeURI', 'decodeURIComponent',
    'encodeURI', 'encodeURIComponent',
    'escape', 'unescape',
    'isFinite', 'isNaN',
    'parseFloat', 'parseInt',
    'Date',
    'Error', 'AggregateError', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',
    'RegExp',
    'JSON',
    'Math',
    'Intl',
    'ArrayBuffer', 'SharedArrayBuffer', 'Uint8Array', 'Uint16Array', 'Int16Array', 'Uint32Array', 'Int32Array',
    'Float32Array', 'Float64Array', 'Uint8ClampedArray', 'BigUint64Array', 'BigInt64Array', 'DataView',
    'BigInt',
    'Map', 'Set', 'WeakMap', 'WeakSet', 'WeakRef',
    'Proxy', 'Reflect',
    'FinalizationRegistry',
    'Atomics',
    'WebAssembly',
]) {
    newGlobalThis[property] = createMock(property, originalGlobalThis[property])
    delete originalGlobalThis[property]
}
Object.setPrototypeOf(globalThis, createMock('globalThis', newGlobalThis))
