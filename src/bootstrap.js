//#region Constants

/** Pattern to extract filename, line and column from stack trace line */
const TRACE_PATTERN = /  at.* \(?(.+):([0-9]+):([0-9]+)\)?$/

/** Pattern that identifies object properties that do not need to be escaped */
const SIMPLE_PROPERTY_PATTERN = /^[a-z_$][a-z0-9_$]*$/i

/** Pattern that matches paths that end in ≥3 repeated properties or have ≥8 simple properties total */
const LOOPED_PATH_PATTERN = /(.+)(\1{2,})$|(\.[a-z0-9_$]+){7,}$/i

/** Symbol to mark objects that are mocks, used to prevent mocking the same object twice */
const MockSymbol = Symbol(`Mock-${Math.random()}`)

/** Symbol to mark fully autogenerated templates, used to prevent mocking missing properties in "real" objects */
const FullMockSymbol = Symbol(`FullMock-${Math.random()}`)

/** Symbol used as a property key to store the value ID of an object */
const IdSymbol = Symbol(`Id-${Math.random()}`)

/** Symbol used to taint previously visited callbacks */
const VisitedSymbol = Symbol(`Visited-${Math.random()}`)

/** Symbol used as a property key to store the function key name (hook name) to be called instead */
const ExternalFunctionSymbol = Symbol(`ExternalFunction-${Math.random()}`)

/** Reference to original properties from globalThis object */
const { Error, JSON, Proxy, Promise, Reflect, Set, eval, isNaN, parseInt } = globalThis // eslint-disable-line no-shadow-restricted-names


//#region Proxies

/**
 * @typedef {import('./Report').Location} Location
 * @typedef {import('./Report').Value} Value
 * @typedef {import('./Report').ReportEvent} ReportEvent
 */

/** @type {import('isolated-vm').Reference} */
const EVENT_PROXY = $1 // eslint-disable-line no-undef

/** @type {import('isolated-vm').Reference} */
const DEBUG_PROXY = $2 // eslint-disable-line no-undef

/** @type {import('isolated-vm').Reference} */
const AWAIT_PROXY = $3 // eslint-disable-line no-undef

/**
 * Next value ID
 */
let nextValueId = parseInt(`${$0.copySync()}`) // eslint-disable-line no-undef

/**
 * Emit event
 * @param {ReportEvent} event Event
 */
function emitEvent(event) {
    EVENT_PROXY.applyIgnored(undefined, [event, nextValueId], { arguments: { copy: true } })
}

/**
 * Emit debug message
 * @param {...unknown} args Arguments to log
 */
function emitDebug(...args) {
    DEBUG_PROXY.applyIgnored(undefined, args.map(item => `${item}`), { arguments: { copy: true } })
}

/**
 * Await reference synchronously
 * @param  {import('isolated-vm').Reference} ref External object reference
 * @return {import('isolated-vm').Reference}     Awaited external object reference
 */
function awaitReference(ref) {
    return AWAIT_PROXY.applySyncPromise(undefined, [ref])
}


//#region Hooks

/** @type {import('isolated-vm').Reference<import('./hooks').Hook[]>} */
const RAW_HOOKS = $4 // eslint-disable-line no-undef

/** @type {Map<string,import('./hooks').Hook>} */
const HOOKS = new Map()

for (const item of RAW_HOOKS.copySync()) {
    HOOKS.set(item.path, item)
}

/**
 * Is external object
 * @param  {any}     input Input variable
 * @return {boolean}       Whether input is an external object
 */
function isExternalObject(input) {
    return (
        typeof input === 'object' &&
        input?.constructor?.name === 'Reference' &&
        input?.typeof !== undefined
    )
}

/**
 * Create external proxy
 * @param  {string} path          Path to new object
 * @param  {any}    maybeExternal External object to wrap
 * @return {any}                  External object wrapped in a proxy
 */
function createExternalProxy(path, maybeExternal) {
    // Skip transferred objects (not external)
    if (!isExternalObject(maybeExternal)) {
        return createMock(path, maybeExternal)
    }

    // Copy transferable objects
    /** @type {import('isolated-vm').Reference} */
    const ref = maybeExternal
    if (ref.typeof !== 'object' && ref.typeof !== 'function') {
        return createMock(path, ref.copySync())
    }

    const target = (ref.typeof === 'function') ? () => {} : {} // eslint-disable-line @typescript-eslint/no-empty-function
    return new Proxy(target, {
        get(target, property) {
            // Handle symbol properties
            if (typeof property === 'symbol') {
                return (property === MockSymbol) ? MockSymbol : target[property]
            }

            // Ignore promises, they are resolved outside the sandbox
            if (property === 'then') {
                return undefined
            }

            // Wrap in a proxy and return
            const newValue = ref.getSync(property, { reference: true })
            const subpath = resolvePath(path, property)
            const newProxy = createExternalProxy(subpath, newValue)
            onGetOrSetEvent('GetEvent', subpath, newProxy)
            return newProxy
        },
        apply(target, thisArg, argArray) {
            return callExternalFunction(path, ref, argArray)
        }
    })
}

/**
 * Call external function
 * @param  {string}                                    path     Path to function
 * @param  {import('isolated-vm').Reference<Function>} ref      External object reference
 * @param  {any[]}                                     argArray Arguments array
 * @return {any}                                                Return value (wrapped in a proxy if needed)
 */
function callExternalFunction(path, ref, argArray) {
    let shouldCopyArguments = true
    const filteredArgArray = []
    for (const item of argArray) {
        // Unsupported types
        if (typeof item === 'symbol' || isMock(item)) {
            filteredArgArray.push({})
            continue
        }

        // Non-transferable values
        if (typeof item === 'function') {
            filteredArgArray.push(item)
            shouldCopyArguments = false
            continue
        }

        // Default case
        filteredArgArray.push(item)
    }

    // Invoke external function
    const resultRef = ref.applySync(undefined, filteredArgArray, {
        arguments: { copy: shouldCopyArguments },
        result: { reference: true },
    })
    const awaitedResultRef = awaitReference(resultRef)

    // Wrap in a proxy and return
    const subpath = resolvePath(path, '()')
    const returns = createExternalProxy(subpath, awaitedResultRef)
    onCallEvent(path, argArray, returns, false)
    return returns
}


//#region Utils

/**
 * Resolve path
 * @param  {string} parentPath Parent path
 * @param  {string} property   Property to append
 * @return {string}            New path
 */
function resolvePath(parentPath, property) {
    if (property === '()') {
        return parentPath.endsWith('()') ? parentPath : `${parentPath}()`
    }

    // Parse property
    if (!isNaN(property)) {
        property = `[${property}]`
    } else if (!SIMPLE_PROPERTY_PATTERN.test(property)) {
        property = `[${JSON.stringify(property)}]`
    }

    // Build new property
    if (parentPath === 'globalThis') {
        return property
    }
    return `${parentPath}${property.startsWith('[') ? '' : '.'}${property}`
}

/**
 * Get current location
 * @return {Location|null} Location or `null` if failed to extract
 */
function getCurrentLocation() {
    // Get stack
    const e = {
        stack: '',
    }
    Error.captureStackTrace(e)

    // Get closest location from stack
    for (const line of e.stack.split('\n').slice(1)) {
        if (line.includes(' (<isolated-vm>:')) {
            // Part of bootstrap code, skip
            continue
        }
        const match = line.match(TRACE_PATTERN)
        if (match === null) {
            // Failed to match, skip
            continue
        }
        return {
            filename: match[1],
            line: parseInt(match[2]),
            column: parseInt(match[3]),
        }
    }

    // Failed to extract location
    return null
}

/**
 * Is literal
 * @param  {any}     input Input variable
 * @return {boolean}       Whether input is a literal
 */
function isLiteral(input) {
    if (input === null || input === undefined) {
        return true
    }
    const type = typeof input
    return (type === 'string' || type === 'number' || type === 'boolean')
}

/**
 * To event value
 * @param  {any}   value Value to wrap
 * @return {Value}       Event value
 */
function toEventValue(value) {
    // Literal values
    if (isLiteral(value)) {
        return { literal: value }
    }

    // Get ID or taint object if needed
    let valueId = value[IdSymbol]
    if (valueId === undefined) {
        valueId = nextValueId++
        value[IdSymbol] = valueId
    }
    return { ref: valueId }
}

/**
 * On get or set event
 * @param {'GetEvent'|'SetEvent'} type  Event type
 * @param {string}                path  Path to variable
 * @param {any}                   value Value being read/written
 */
function onGetOrSetEvent(type, path, value) {
    const location = getCurrentLocation()
    if (location === null) {
        emitDebug(`Ignored ${type} with unknown location for "${path}"`)
        return
    }
    emitDebug(`${type === 'GetEvent' ? 'Got' : 'Set'} ${path}`)
    emitEvent({
        type,
        path,
        value: toEventValue(value),
        location,
    })
}

/**
 * On call event
 * @param {string}  path          Path to variable being called
 * @param {any[]}   argArray      Call arguments
 * @param {any}     returns       Return value
 * @param {boolean} isConstructor Is call from constructor
 */
function onCallEvent(path, argArray, returns, isConstructor) {
    const normalizedPath = path.endsWith('()') ? path.slice(0, -2) : path
    emitDebug(`Called ${normalizedPath}(${argArray.map(() => '#').join(', ')})`)

    // Emit event
    const wrappedArguments = []
    for (const value of argArray) {
        wrappedArguments.push(toEventValue(value))
    }
    emitEvent({
        type: 'CallEvent',
        path: normalizedPath,
        arguments: wrappedArguments,
        returns: toEventValue(returns),
        isConstructor,
        location: getCurrentLocation(),
    })

    // Visit callback arguments (if any)
    visitCallback(argArray)
}


//#region Mocks

/**
 * Is mock
 * @param  {any}     object Object to check
 * @return {boolean}        Whether object is mock
 */
function isMock(object) {
    try {
        return (object[MockSymbol] === MockSymbol)
    } catch (_) {
        return false
    }
}

/**
 * Create mock object (if possible)
 * @param  {string} path       Path to new object
 * @param  {any}    [template] Template to mock
 * @param  {any}    [thisArg]  For functions, custom `this` argument used during invocation
 * @return {object}            Mock object
 */
function createMock(path, template, thisArg) {
    // Is template a primitive type?
    const type = typeof template
    if (template === null || type === 'string' || type === 'number' || type === 'boolean' || type === 'symbol') {
        return template
    }

    // Create fully mock template if needed
    if (template === undefined) {
        template = function() {
            const subpath = resolvePath(path, '()')
            emitDebug(`Mocked return value for ${subpath}`)
            return createMock(subpath)
        }
        template.toString = () => 'function () { [native code] }'
        template[Symbol.iterator] = function* () {
            for (let i=0; i<5; i++) {
                yield createMock(resolvePath(path, `${i}`))
            }
        }
        template[FullMockSymbol] = FullMockSymbol
    }

    // Wrap template in proxy
    /** @type {Set<string>} */
    const silentPaths = new Set()
    /** @type {Set<string>} */
    const readOnlyPaths = new Set()
    const proxy = new Proxy(template, {
        has(target, property) {
            return (target[FullMockSymbol] === FullMockSymbol) ? true : (property in target)
        },
        get(target, property) {
            // Handle symbol properties
            if (typeof property === 'symbol') {
                return (property === MockSymbol) ? MockSymbol : target[property]
            }

            // Handle ignored properties
            if (property === 'apply' || property === 'bind' || property === 'call') {
                return target[property]
            }

            // Handle thenable functions
            if (property === 'then') {
                if (!(property in target)) {
                    let resolve, reject
                    target[property] = new Promise((res, rej) => {
                        resolve = res
                        reject = rej
                    })
                    visitCallback([resolve, reject], proxy)
                }
                return target[property]
            }

            // Create or get child mock
            const subpath = resolvePath(path, property)
            const exists = (property in target)
            if (!exists && HOOKS.has(subpath)) {
                const hook = HOOKS.get(subpath)
                if ('newPath' in hook) {
                    emitDebug(`Created hook redirecting "${subpath}" to "${hook.newPath}"`)
                    target[property] = eval(hook.newPath)
                    silentPaths.add(subpath)
                } else if ('value' in hook) {
                    emitDebug(`Created hook with custom value for "${subpath}"`)
                    const value = hook.value.copy()
                    target[property] = (value === undefined) ? undefined : createMock(subpath, value)
                } else {
                    emitDebug(`Created hook binding external function at "${subpath}"`)
                    target[property] = createMock(subpath)
                    target[property][ExternalFunctionSymbol] = subpath
                }
                if (!hook.isWritable) {
                    readOnlyPaths.add(subpath)
                }
            } else if (!exists) {
                if (LOOPED_PATH_PATTERN.test(subpath)) {
                    emitDebug(`Found looped path at "${subpath}", skipped`)
                    target[property] = undefined
                } else {
                    emitDebug(`Mocked "${subpath}" object`)
                    target[property] = createMock(subpath)
                }
            } else if (!isLiteral(target[property]) && !isMock(target[property])) {
                emitDebug(`Patched existing "${subpath}" object`)
                target[property] = createMock(subpath, target[property], target)
            }

            // Return value
            if (!subpath.endsWith('.prototype') && !silentPaths.has(subpath)) {
                onGetOrSetEvent('GetEvent', subpath, target[property])
            }
            return target[property]
        },
        set(target, property, newValue, receiver) {
            if (typeof property === 'string') {
                const subpath = resolvePath(path, property)
                onGetOrSetEvent('SetEvent', subpath, newValue)
                if (readOnlyPaths.has(subpath)) {
                    emitDebug(`Ignored set value attempt for "${subpath}" (read-only)`)
                    return true
                }
                if (!isMock(newValue)) {
                    emitDebug(`Patched existing "${subpath}" object before setting value`)
                    newValue = createMock(subpath, newValue, target)
                }
            }
            return Reflect.set(target, property, newValue, receiver)
        },
        construct(target, argArray, newTarget) {
            const newInstance = Reflect.construct(target, argArray, newTarget)
            const subpath = resolvePath(path, '()')

            // Wrap new instance in mock if needed
            let newMock
            if (isMock(newInstance)) {
                emitDebug(`"${subpath}" is already a mock, not mocking again`)
                newMock = newInstance
            } else {
                newMock = createMock(subpath, newInstance)
            }

            // Return value
            onCallEvent(path, argArray, newMock, true)
            return newMock
        },
        apply(target, realThisArg, argArray) {
            // Handle hooks of external functions
            if (typeof target[ExternalFunctionSymbol] === 'string') {
                const hookPath = target[ExternalFunctionSymbol]
                const hook = HOOKS.get(hookPath)
                if (hook && 'function' in hook) {
                    return callExternalFunction(path, hook.function, argArray)
                }
                emitDebug(`Trying to invoke non-existing external function: "${hookPath}"`)
            }

            // Call function
            const returns = target.apply(thisArg ?? realThisArg, argArray)
            onCallEvent(path, argArray, returns, false)
            return returns
        },
    })

    return proxy
}

/**
 * Visit callback if not already visited
 * @param {any[]} candidates         Candidates to pick first valid callback from
 * @param {any}   [valueToPropagate] Optional value to propagate as the first call argument
 */
function visitCallback(candidates, valueToPropagate) {
    try {
        for (const callback of candidates) {
            if (typeof callback === 'function' && !isMock(callback) && callback[VisitedSymbol] !== VisitedSymbol) {
                callback[VisitedSymbol] = VisitedSymbol
                if (valueToPropagate === undefined) {
                    callback()
                } else {
                    callback(valueToPropagate)
                }
                break
            }
        }
    } catch (_) {
        // Ignore error and keep running
    }
}


//#region Initialize

// Hijack globalThis object
const originalGlobalThis = globalThis
const newGlobalThis = {}
newGlobalThis[Symbol.toPrimitive] = () => '[object Window]'
newGlobalThis[FullMockSymbol] = FullMockSymbol
for (const property of [
    'console',
    'eval',
    'decodeURI', 'decodeURIComponent',
    'encodeURI', 'encodeURIComponent',
    'escape', 'unescape',
    'isFinite', 'isNaN',
    'parseFloat', 'parseInt',
    'Date',
    'Error', 'AggregateError', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',
    'RegExp',
    'JSON',
    'Math',
    'Intl',
    'ArrayBuffer', 'SharedArrayBuffer', 'Uint8Array', 'Uint16Array', 'Int16Array', 'Uint32Array', 'Int32Array',
    'Float32Array', 'Float64Array', 'Uint8ClampedArray', 'BigUint64Array', 'BigInt64Array', 'DataView',
    'BigInt',
    'Map', 'Set', 'WeakMap', 'WeakSet', 'WeakRef',
    'Proxy', 'Reflect',
    'FinalizationRegistry',
    'Atomics',
    'WebAssembly',
]) {
    newGlobalThis[property] = createMock(property, originalGlobalThis[property])
    delete originalGlobalThis[property] // eslint-disable-line @typescript-eslint/no-dynamic-delete
}
Object.setPrototypeOf(globalThis, createMock('globalThis', newGlobalThis))
